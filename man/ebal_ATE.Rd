% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/ebal_ATE.R
\name{ebal_ATE}
\alias{ebal_ATE}
\title{Entropy balancing ATE for causal generalization}
\usage{
ebal_ATE(x, y, trt, H_vars, target_moments, H_add_intercept = TRUE, delta)
}
\arguments{
\item{x}{A data matrix for the source sample. Each column represents
source sample covariate and each row represents an observation.}

\item{y}{A vector of the source sample response values.}

\item{trt}{A vector of 0, 1 or TRUE/FALSE of treatment assignment for the source sample.}

\item{H_vars}{A vector of numbers indexing which covariate in \code{x}
need to be balanced between source and target samples.}

\item{target_moments}{A vector of first moments of the target sample covariates
that needs to be balanced between source and target.}

\item{H_add_intercept}{`logical` whether to include 1 as intercept in
H covariates, default as TRUE.}

\item{delta}{A vector specifying the approximate balancing tolerance margin.
The vector has a total length of H+H+G, where H represents the number of
covariates balanced between the source (treatment and control) and the
target moments, and G represents the covariates balanced solely between
the source treatment and control groups. If exact balancing, delta are all zeros.}
}
\value{
A list containing:
\describe{
  \item{ate_est}{ATE for causal generalization.}
 \item{constant}{The final constant used for the approximate balancing
 tolerance margin if no feasible solution is achieved with the specified `delta`.
 If the specified `delta` results in a feasible solution, the constant remains 0.
 Otherwise, the constant is incrementally increased, multiplying `delta`
 until a feasible solution is found.}
 }
}
\description{
Compute the exact and approximate Average Treatment Effect (ATE)
using entropy balancing weights proposed in the paper.

If the tolerance margin \code{delta} is all 0, it computes the exact balancing ATE.
Otherwise, it computes the approximate balancing ATE. If exact balancing
does not yield a feasible solution, the standard deviation of \code{x} is
used as \code{delta} , which convert exact into approximate balancing.

If the specified \code{delta} does not yield a feasible solution, for approximate balancing,
the constant is increased (starting from 1) by 1 times delta until a solution is found.
For exact balancing that later uses the standard deviation as \code{delta},
the constant is increased (starting from 0) by 0.1 times delta until a solution is achieved.
}
\details{
`ebal_ATE` computes causal generalized ATE from source to the target sample by
estimating entropy balancing weights. See Chen, Chen, Yu (2023) method details
for the exact balancing set up.
}
\examples{
library(EBalGen)
set.seed(1)
n = 100
p = 5
x = runif(n * p)
x = matrix(4 * x - 2, n, p)
y = rnorm(n*p)
trt = rbinom(n,1,0.5)
H_vars = c(1,2,3)
target_moments = c(0,0,0)

## Exact balancing ATE
delta = numeric(8)
library(dplyr)
ebal_ATE(x,y,trt,H_vars, target_moments = target_moments, H_add_intercept = TRUE,delta)

## Approximate balancing ATE requires installation of MOSEK for optimization.
delta = numeric(8)+0.1
if (requireNamespace("CVXR", quietly = TRUE)) {
  library(dplyr)
  if (!("MOSEK" \%in\% CVXR::installed_solvers())) {
    stop("MOSEK solver is not installed. Please install MOSEK to use it with CVXR.")}
  ebal_ATE(x,y,trt,H_vars, target_moments = target_moments, H_add_intercept = TRUE,delta)

}
}
\references{
Chen, R., Chen, G., & Yu, M. (2023). Entropy balancing for causal
generalization with target sample summary information. Biometrics, 79(4)
}
